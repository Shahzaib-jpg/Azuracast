/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_name_"] = self["webpackChunk_name_"] || []).push([["vendor-vue-gettext"],{

/***/ "./node_modules/vue-gettext/dist/vue-gettext.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-gettext/dist/vue-gettext.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * vue-gettext v2.1.12\n * (c) 2020 Polyconseil\n * @license MIT\n */\n(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, function (exports) { 'use strict';\n\n  // Polyfill Object.assign for legacy browsers.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n  if (typeof Object.assign !== 'function') {\n    (function () {\n      Object.assign = function (target) {\n        var arguments$1 = arguments;\n\n        var output;\n        var index;\n        var source;\n        var nextKey;\n        if (target === undefined || target === null) {\n          throw new TypeError('Cannot convert undefined or null to object')\n        }\n        output = Object(target);\n        for (index = 1; index < arguments.length; index++) {\n          source = arguments$1[index];\n          if (source !== undefined && source !== null) {\n            for (nextKey in source) {\n              if (source.hasOwnProperty(nextKey)) {\n                output[nextKey] = source[nextKey];\n              }\n            }\n          }\n        }\n        return output\n      };\n    }());\n  }\n\n  /**\n   * Plural Forms\n   *\n   * This is a list of the plural forms, as used by Gettext PO, that are appropriate to each language.\n   * http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html\n   *\n   * This is a replica of angular-gettext's plural.js\n   * https://github.com/rubenv/angular-gettext/blob/master/src/plural.js\n   */\n  var plurals = {\n\n    getTranslationIndex: function (languageCode, n) {\n\n      n = Number(n);\n      n = typeof n === 'number' && isNaN(n) ? 1 : n;  // Fallback to singular.\n\n      // Extract the ISO 639 language code. The ISO 639 standard defines\n      // two-letter codes for many languages, and three-letter codes for\n      // more rarely used languages.\n      // https://www.gnu.org/software/gettext/manual/html_node/Language-Codes.html#Language-Codes\n      if (languageCode.length > 2 && languageCode !== 'pt_BR') {\n        languageCode = languageCode.split('_')[0];\n      }\n\n      switch (languageCode) {\n        case 'ay':  // AymarÃ¡\n        case 'bo':  // Tibetan\n        case 'cgg': // Chiga\n        case 'dz':  // Dzongkha\n        case 'fa':  // Persian\n        case 'id':  // Indonesian\n        case 'ja':  // Japanese\n        case 'jbo': // Lojban\n        case 'ka':  // Georgian\n        case 'kk':  // Kazakh\n        case 'km':  // Khmer\n        case 'ko':  // Korean\n        case 'ky':  // Kyrgyz\n        case 'lo':  // Lao\n        case 'ms':  // Malay\n        case 'my':  // Burmese\n        case 'sah': // Yakut\n        case 'su':  // Sundanese\n        case 'th':  // Thai\n        case 'tt':  // Tatar\n        case 'ug':  // Uyghur\n        case 'vi':  // Vietnamese\n        case 'wo':  // Wolof\n        case 'zh':  // Chinese\n          // 1 form\n          return 0\n        case 'is':  // Icelandic\n          // 2 forms\n          return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0\n        case 'jv':  // Javanese\n          // 2 forms\n          return n !== 0 ? 1 : 0\n        case 'mk':  // Macedonian\n          // 2 forms\n          return n === 1 || n % 10 === 1 ? 0 : 1\n        case 'ach': // Acholi\n        case 'ak':  // Akan\n        case 'am':  // Amharic\n        case 'arn': // Mapudungun\n        case 'br':  // Breton\n        case 'fil': // Filipino\n        case 'fr':  // French\n        case 'gun': // Gun\n        case 'ln':  // Lingala\n        case 'mfe': // Mauritian Creole\n        case 'mg':  // Malagasy\n        case 'mi':  // Maori\n        case 'oc':  // Occitan\n        case 'pt_BR':  // Brazilian Portuguese\n        case 'tg':  // Tajik\n        case 'ti':  // Tigrinya\n        case 'tr':  // Turkish\n        case 'uz':  // Uzbek\n        case 'wa':  // Walloon\n        /* eslint-disable */\n        /* Disable \"Duplicate case label\" because there are 2 forms of Chinese plurals */\n        case 'zh':  // Chinese\n        /* eslint-enable */\n          // 2 forms\n          return n > 1 ? 1 : 0\n        case 'lv':  // Latvian\n          // 3 forms\n          return (n % 10 === 1 && n % 100 !== 11 ? 0 : n !== 0 ? 1 : 2)\n        case 'lt':  // Lithuanian\n          // 3 forms\n          return (n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2)\n        case 'be':  // Belarusian\n        case 'bs':  // Bosnian\n        case 'hr':  // Croatian\n        case 'ru':  // Russian\n        case 'sr':  // Serbian\n        case 'uk':  // Ukrainian\n          // 3 forms\n          return (\n            n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2)\n        case 'mnk': // Mandinka\n          // 3 forms\n          return (n === 0 ? 0 : n === 1 ? 1 : 2)\n        case 'ro':  // Romanian\n          // 3 forms\n          return (n === 1 ? 0 : (n === 0 || (n % 100 > 0 && n % 100 < 20)) ? 1 : 2)\n        case 'pl':  // Polish\n          // 3 forms\n          return (n === 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2)\n        case 'cs':  // Czech\n        case 'sk':  // Slovak\n          // 3 forms\n          return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2\n        case 'csb': // Kashubian\n          // 3 forms\n          return (n === 1) ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2\n        case 'sl':  // Slovenian\n          // 4 forms\n          return (n % 100 === 1 ? 0 : n % 100 === 2 ? 1 : n % 100 === 3 || n % 100 === 4 ? 2 : 3)\n        case 'mt':  // Maltese\n          // 4 forms\n          return (n === 1 ? 0 : n === 0 || (n % 100 > 1 && n % 100 < 11) ? 1 : (n % 100 > 10 && n % 100 < 20) ? 2 : 3)\n        case 'gd':  // Scottish Gaelic\n          // 4 forms\n          return (n === 1 || n === 11) ? 0 : (n === 2 || n === 12) ? 1 : (n > 2 && n < 20) ? 2 : 3\n        case 'cy':  // Welsh\n          // 4 forms\n          return (n === 1) ? 0 : (n === 2) ? 1 : (n !== 8 && n !== 11) ? 2 : 3\n        case 'kw':  // Cornish\n          // 4 forms\n          return (n === 1) ? 0 : (n === 2) ? 1 : (n === 3) ? 2 : 3\n        case 'ga':  // Irish\n          // 5 forms\n          return n === 1 ? 0 : n === 2 ? 1 : (n > 2 && n < 7) ? 2 : (n > 6 && n < 11) ? 3 : 4\n        case 'ar':  // Arabic\n          // 6 forms\n          return (n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5)\n        default: // Everything else\n          return n !== 1 ? 1 : 0\n      }\n    },\n\n  };\n\n  // Ensure to always use the same Vue instance throughout the plugin.\n  //\n  // This was previously done in `index.js` using both named and default exports.\n  // However, this currently must be kept in a separate file because we are using\n  // Rollup to build the dist files and it has a drawback when using named and\n  // default exports together, see:\n  // https://github.com/rollup/rollup/blob/fca14d/src/utils/getExportMode.js#L27\n  // https://github.com/rollup/rollup/wiki/JavaScript-API#exports\n  //\n  // If we had kept named and default exports in `index.js`, a user would have to\n  // do something like this to access the default export: GetTextPlugin['default']\n\n  var _Vue;\n\n  function shareVueInstance (Vue) {\n    _Vue = Vue;\n  }\n\n  var EVALUATION_RE = /[[\\].]{1,2}/g;\n\n  /* Interpolation RegExp.\n   *\n   * Because interpolation inside attributes are deprecated in Vue 2 we have to\n   * use another set of delimiters to be able to use `translate-plural` etc.\n   * We use %{ } delimiters.\n   *\n   * /\n   *   %\\{                => Starting delimiter: `%{`\n   *     (                => Start capture\n   *       (?:.|\\n)       => Non-capturing group: any character or newline\n   *       +?             => One or more times (ungreedy)\n   *     )                => End capture\n   *   \\}                 => Ending delimiter: `}`\n   * /g                   => Global: don't return after first match\n   */\n  var INTERPOLATION_RE = /%\\{((?:.|\\n)+?)\\}/g;\n\n  var MUSTACHE_SYNTAX_RE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n\n  /**\n   * Evaluate a piece of template string containing %{ } placeholders.\n   * E.g.: 'Hi %{ user.name }' => 'Hi Bob'\n   *\n   * This is a vm.$interpolate alternative for Vue 2.\n   * https://vuejs.org/v2/guide/migration.html#vm-interpolate-removed\n   *\n   * @param {String} msgid - The translation key containing %{ } placeholders\n   * @param {Object} context - An object whose elements are put in their corresponding placeholders\n   *\n   * @return {String} The interpolated string\n   */\n  var interpolate = function (msgid, context, disableHtmlEscaping) {\n    if ( context === void 0 ) context = {};\n    if ( disableHtmlEscaping === void 0 ) disableHtmlEscaping = false;\n\n\n    if (_Vue && !_Vue.config.getTextPluginSilent && MUSTACHE_SYNTAX_RE.test(msgid)) {\n      console.warn((\"Mustache syntax cannot be used with vue-gettext. Please use \\\"%{}\\\" instead of \\\"{{}}\\\" in: \" + msgid));\n    }\n\n    var result = msgid.replace(INTERPOLATION_RE, function (match, token) {\n\n      var expression = token.trim();\n      var evaluated;\n\n      var escapeHtmlMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        '\\'': '&#039;',\n      };\n\n      // Avoid eval() by splitting `expression` and looping through its different properties if any, see #55.\n      function getProps (obj, expression) {\n        var arr = expression.split(EVALUATION_RE).filter(function (x) { return x; });\n        while (arr.length) {\n          obj = obj[arr.shift()];\n        }\n        return obj\n      }\n\n      function evalInContext (expression) {\n        try {\n          evaluated = getProps(this, expression);\n        } catch (e) {\n          // Ignore errors, because this function may be called recursively later.\n        }\n        if (evaluated === undefined) {\n          if (this.$parent) {\n            // Recursively climb the $parent chain to allow evaluation inside nested components, see #23 and #24.\n            return evalInContext.call(this.$parent, expression)\n          } else {\n            console.warn((\"Cannot evaluate expression: \" + expression));\n            evaluated = expression;\n          }\n        }\n        var result = evaluated.toString();\n        if (disableHtmlEscaping) {\n          // Do not escape HTML, see #78.\n          return result\n        }\n        // Escape HTML, see #78.\n        return result.replace(/[&<>\"']/g, function (m) { return escapeHtmlMap[m] })\n      }\n\n      return evalInContext.call(context, expression)\n\n    });\n\n    return result\n\n  };\n\n  // Store this values as function attributes for easy access elsewhere to bypass a Rollup\n  // weak point with `export`:\n  // https://github.com/rollup/rollup/blob/fca14d/src/utils/getExportMode.js#L27\n  interpolate.INTERPOLATION_RE = INTERPOLATION_RE;\n  interpolate.INTERPOLATION_PREFIX = '%{';\n\n  var SPACING_RE = /\\s{2,}/g;\n\n  // Default configuration if only the translation is passed.\n  var _config = {\n    language: '',\n    getTextPluginSilent: false,\n    getTextPluginMuteLanguages: [],\n    silent: false,\n  };\n  var _translations = {};\n\n  var translate = {\n\n    /*\n     * Get the translated string from the translation.json file generated by easygettext.\n     *\n     * @param {String} msgid - The translation key\n     * @param {Number} n - The number to switch between singular and plural\n     * @param {String} context - The translation key context\n     * @param {String} defaultPlural - The default plural value (optional)\n     * @param {String} language - The language ID (e.g. 'fr_FR' or 'en_US')\n     *\n     * @return {String} The translated string\n    */\n    getTranslation: function (msgid, n, context, defaultPlural, language) {\n      if ( n === void 0 ) n = 1;\n      if ( context === void 0 ) context = null;\n      if ( defaultPlural === void 0 ) defaultPlural = null;\n      if ( language === void 0 ) language = _config.language;\n\n\n      if (!msgid) {\n        return ''  // Allow empty strings.\n      }\n\n      var silent = _config.getTextPluginSilent || (_config.getTextPluginMuteLanguages.indexOf(language) !== -1);\n\n      // Default untranslated string, singular or plural.\n      var untranslated = defaultPlural && plurals.getTranslationIndex(language, n) > 0 ? defaultPlural : msgid;\n\n      // `easygettext`'s `gettext-compile` generates a JSON version of a .po file based on its `Language` field.\n      // But in this field, `ll_CC` combinations denoting a languageâs main dialect are abbreviated as `ll`,\n      // for example `de` is equivalent to `de_DE` (German as spoken in Germany).\n      // See the `Language` section in https://www.gnu.org/software/gettext/manual/html_node/Header-Entry.html\n      // So try `ll_CC` first, or the `ll` abbreviation which can be three-letter sometimes:\n      // https://www.gnu.org/software/gettext/manual/html_node/Language-Codes.html#Language-Codes\n      var translations = _translations[language] || _translations[language.split('_')[0]];\n\n      if (!translations) {\n        if (!silent) {\n          console.warn((\"No translations found for \" + language));\n        }\n        return untranslated\n      }\n\n      // Currently easygettext trims entries since it needs to output consistent PO translation content\n      // even if a web template designer added spaces between lines (which are ignored in HTML or jade,\n      // but are significant in text). See #65.\n      // Replicate the same behaviour here.\n      msgid = msgid.trim();\n\n      var translated = translations[msgid];\n\n      // Sometimes `msgid` may not have the same number of spaces than its translation key.\n      // This could happen because we use the private attribute `_renderChildren` to access the raw uninterpolated\n      // string to translate in the `created` hook of `component.js`: spaces are not exactly the same between the\n      // HTML and the content of `_renderChildren`, e.g. 6 spaces becomes 4 etc. See #15, #38.\n      // In such cases, we need to compare the translation keys and `msgid` with the same number of spaces.\n      if (!translated && SPACING_RE.test(msgid)) {\n        Object.keys(translations).some(function (key) {\n          if (key.replace(SPACING_RE, ' ') === msgid.replace(SPACING_RE, ' ')) {\n            translated = translations[key];\n            return translated\n          }\n        });\n      }\n\n      if (translated && context) {\n        translated = translated[context];\n      }\n\n      if (!translated) {\n        if (!silent) {\n          var msg = \"Untranslated \" + language + \" key found: \" + msgid;\n          if (context) {\n            msg += \" (with context: \" + context + \")\";\n          }\n          console.warn(msg);\n        }\n        return untranslated\n      }\n\n      // Avoid a crash when a msgid exists with and without a context, see #32.\n      if (!(translated instanceof Array) && translated.hasOwnProperty('')) {\n        // As things currently stand, the void key means a void context for easygettext.\n        translated = translated[''];\n      }\n\n      if (typeof translated === 'string') {\n        translated = [translated];\n      }\n\n      var translationIndex = plurals.getTranslationIndex(language, n);\n\n      // Do not assume that the default value of n is 1 for the singular form of all languages.\n      // E.g. Arabic, see #69.\n      if (translated.length === 1 && n === 1) {\n        translationIndex = 0;\n      }\n\n      return translated[translationIndex]\n\n    },\n\n    /*\n     * Returns a string of the translation of the message.\n     * Also makes the string discoverable by gettext-extract.\n     *\n     * @param {String} msgid - The translation key\n     * @param {String} language - The language ID (e.g. 'fr_FR' or 'en_US')\n     *\n     * @return {String} The translated string\n    */\n    'gettext': function (msgid, language) {\n      if ( language === void 0 ) language = _config.language;\n\n      return translate.getTranslation(msgid, 1, null, null, language)\n    },\n\n    /*\n     * Returns a string of the translation for the given context.\n     * Also makes the string discoverable by gettext-extract.\n     *\n     * @param {String} context - The context of the string to translate\n     * @param {String} msgid - The translation key\n     * @param {String} language - The language ID (e.g. 'fr_FR' or 'en_US')\n     *\n     * @return {String} The translated string\n    */\n    'pgettext': function (context, msgid, language) {\n      if ( language === void 0 ) language = _config.language;\n\n      return translate.getTranslation(msgid, 1, context, null, language)\n    },\n\n    /*\n     * Returns a string of the translation of either the singular or plural,\n     * based on the number.\n     * Also makes the string discoverable by gettext-extract.\n     *\n     * @param {String} msgid - The translation key\n     * @param {String} plural - The plural form of the translation key\n     * @param {Number} n - The number to switch between singular and plural\n     * @param {String} language - The language ID (e.g. 'fr_FR' or 'en_US')\n     *\n     * @return {String} The translated string\n    */\n    'ngettext': function (msgid, plural, n, language) {\n      if ( language === void 0 ) language = _config.language;\n\n      return translate.getTranslation(msgid, n, null, plural, language)\n    },\n\n    /*\n     * Returns a string of the translation of either the singular or plural,\n     * based on the number, for the given context.\n     * Also makes the string discoverable by gettext-extract.\n     *\n     * @param {String} context - The context of the string to translate\n     * @param {String} msgid - The translation key\n     * @param {String} plural - The plural form of the translation key\n     * @param {Number} n - The number to switch between singular and plural\n     * @param {String} language - The language ID (e.g. 'fr_FR' or 'en_US')\n     *\n     * @return {String} The translated string\n    */\n    'npgettext': function (context, msgid, plural, n, language) {\n      if ( language === void 0 ) language = _config.language;\n\n      return translate.getTranslation(msgid, n, context, plural, language)\n    },\n\n    /*\n     * Initialize local state for translations and configuration\n     * so that it works without Vue.\n     *\n     * @param {Object} translations - translations.json\n     * @param {Object} config - Vue.config\n     *\n    */\n    initTranslations: function (translations, config) {\n      if (translations && typeof translations === 'object') {\n        _translations = translations;\n      }\n      if (config && typeof config === 'object') {\n        _config = config;\n      }\n    },\n\n    /**\n     * Allows to use interpolation outside the Vue\n     *\n     * @example\n     *  import {translate} from 'vue-gettext';\n     *\n     *  const {gettext, gettextInterpolate} = translate;\n     *\n     *  let translated = gettext('%{ n } foos', n)\n     *  let interpolated = gettextInterpolate(translated, {n: 5})\n     */\n    gettextInterpolate: interpolate.bind(interpolate),\n\n  };\n\n  // UUID v4 generator (RFC4122 compliant).\n  //\n  // https://gist.github.com/jcxplorer/823878\n\n  function uuid () {\n\n    var uuid = '';\n    var i;\n    var random;\n\n    for (i = 0; i < 32; i++) {\n      random = Math.random() * 16 | 0;\n      if (i === 8 || i === 12 || i === 16 || i === 20) {\n        uuid += '-';\n      }\n      uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);\n    }\n\n    return uuid\n\n  }\n\n  /**\n   * Translate content according to the current language.\n   */\n  var Component = {\n\n    name: 'translate',\n\n    created: function () {\n\n      this.msgid = '';  // Don't crash the app with an empty component, i.e.: <translate></translate>.\n\n      // Store the raw uninterpolated string to translate.\n      // This is currently done by looking inside a private attribute `_renderChildren`.\n      // I haven't (yet) found a better way to access the raw content of the component.\n      if (this.$options._renderChildren) {\n        if (this.$options._renderChildren[0].hasOwnProperty('text')) {\n          this.msgid = this.$options._renderChildren[0].text;\n        } else {\n          this.msgid = this.$options._renderChildren[0];\n        }\n      }\n\n      this.isPlural = this.translateN !== undefined && this.translatePlural !== undefined;\n      if (!this.isPlural && (this.translateN || this.translatePlural)) {\n        throw new Error((\"`translate-n` and `translate-plural` attributes must be used together: \" + (this.msgid) + \".\"))\n      }\n\n    },\n\n    props: {\n      tag: {\n        type: String,\n        default: 'span',\n      },\n      // Always use v-bind for dynamically binding the `translateN` prop to data on the parent,\n      // i.e.: `:translateN`.\n      translateN: {\n        type: Number,\n        required: false,\n      },\n      translatePlural: {\n        type: String,\n        required: false,\n      },\n      translateContext: {\n        type: String,\n        required: false,\n      },\n      translateParams: {\n        type: Object,\n        required: false,\n      },\n      // `translateComment` is used exclusively by `easygettext`'s `gettext-extract`.\n      translateComment: {\n        type: String,\n        required: false,\n      },\n    },\n\n    computed: {\n      translation: function () {\n        var translation = translate.getTranslation(\n          this.msgid,\n          this.translateN,\n          this.translateContext,\n          this.isPlural ? this.translatePlural : null,\n          this.$language.current\n        );\n\n        var context = this.$parent;\n\n        if (this.translateParams) {\n          context = Object.assign({}, this.$parent, this.translateParams);\n        }\n\n        return this.$gettextInterpolate(translation, context)\n      },\n    },\n\n    render: function (createElement) {\n\n      // Fix the problem with v-if, see #29.\n      // Vue re-uses DOM elements for efficiency if they don't have a key attribute, see:\n      // https://vuejs.org/v2/guide/conditional.html#Controlling-Reusable-Elements-with-key\n      // https://vuejs.org/v2/api/#key\n      if (_Vue.config.autoAddKeyAttributes && !this.$vnode.key) {\n        this.$vnode.key = uuid();\n      }\n\n      // The text must be wraped inside a root HTML element, so we use a <span> (by default).\n      // https://github.com/vuejs/vue/blob/a4fcdb/src/compiler/parser/index.js#L209\n      return createElement(this.tag, [this.translation])\n\n    },\n\n  };\n\n  // Check if two values are loosely equal - that is,\n  // if they are plain objects, do they have the same shape?\n  // https://github.com/vuejs/vue/blob/v2.6.11/src/shared/util.js#L285\n\n  function looseEqual (a, b) {\n    if (a === b) { return true }\n    var isObjectA = a !== null && typeof a === 'object';\n    var isObjectB = b !== null && typeof b === 'object';\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i])\n          })\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime()\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key])\n          })\n        } else {\n          return false\n        }\n      } catch (e) {\n        return false\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b)\n    } else {\n      return false\n    }\n  }\n\n  var updateTranslation = function (el, binding, vnode) {\n\n    var attrs = vnode.data.attrs || {};\n    var msgid = el.dataset.msgid;\n    var translateContext = attrs['translate-context'];\n    var translateN = attrs['translate-n'];\n    var translatePlural = attrs['translate-plural'];\n    var isPlural = translateN !== undefined && translatePlural !== undefined;\n    var context = vnode.context;\n    var disableHtmlEscaping = attrs['render-html'] === 'true';\n\n    if (!isPlural && (translateN || translatePlural)) {\n      throw new Error('`translate-n` and `translate-plural` attributes must be used together:' + msgid + '.')\n    }\n\n    if (!_Vue.config.getTextPluginSilent && attrs['translate-params']) {\n      console.warn((\"`translate-params` is required as an expression for v-translate directive. Please change to `v-translate='params'`: \" + msgid));\n    }\n\n    if (binding.value && typeof binding.value === 'object') {\n      context = Object.assign({}, vnode.context, binding.value);\n    }\n\n    var translation = translate.getTranslation(\n      msgid,\n      translateN,\n      translateContext,\n      isPlural ? translatePlural : null,\n      el.dataset.currentLanguage\n    );\n\n    var msg = interpolate(translation, context, disableHtmlEscaping);\n\n    el.innerHTML = msg;\n\n  };\n\n  /**\n   * A directive to translate content according to the current language.\n   *\n   * Use this directive instead of the component if you need to translate HTML content.\n   * It's too tricky to support HTML content within the component because we cannot get the raw HTML to use as `msgid`.\n   *\n   * This directive has a similar interface to the <translate> component, supporting\n   * `translate-comment`, `translate-context`, `translate-plural`, `translate-n`.\n   *\n   * `<p v-translate translate-comment='Good stuff'>This is <strong class='txt-primary'>Sparta</strong>!</p>`\n   *\n   * If you need interpolation, you must add an expression that outputs binding value that changes with each of the\n   * context variable:\n   * `<p v-translate=\"fullName + location\">I am %{ fullName } and from %{ location }</p>`\n   */\n  var Directive = {\n\n    bind: function bind (el, binding, vnode) {\n\n      // Fix the problem with v-if, see #29.\n      // Vue re-uses DOM elements for efficiency if they don't have a key attribute, see:\n      // https://vuejs.org/v2/guide/conditional.html#Controlling-Reusable-Elements-with-key\n      // https://vuejs.org/v2/api/#key\n      if (_Vue.config.autoAddKeyAttributes && !vnode.key) {\n        vnode.key = uuid();\n      }\n\n      // Get the raw HTML and store it in the element's dataset (as advised in Vue's official guide).\n      var msgid = el.innerHTML;\n      el.dataset.msgid = msgid;\n\n      // Store the current language in the element's dataset.\n      el.dataset.currentLanguage = _Vue.config.language;\n\n      // Output an info in the console if an interpolation is required but no expression is provided.\n      if (!_Vue.config.getTextPluginSilent) {\n        var hasInterpolation = msgid.indexOf(interpolate.INTERPOLATION_PREFIX) !== -1;\n        if (hasInterpolation && !binding.expression) {\n          console.info((\"No expression is provided for change detection. The translation for this key will be static:\\n\" + msgid));\n        }\n      }\n\n      updateTranslation(el, binding, vnode);\n\n    },\n\n    update: function update (el, binding, vnode) {\n\n      var doUpdate = false;\n\n      // Trigger an update if the language has changed.\n      if (el.dataset.currentLanguage !== _Vue.config.language) {\n        el.dataset.currentLanguage = _Vue.config.language;\n        doUpdate = true;\n      }\n\n      // Trigger an update if an optional bound expression has changed.\n      if (!doUpdate && binding.expression && !looseEqual(binding.value, binding.oldValue)) {\n        doUpdate = true;\n      }\n\n      if (doUpdate) {\n        updateTranslation(el, binding, vnode);\n      }\n\n    },\n\n  };\n\n  function Config (Vue, languageVm, getTextPluginSilent, autoAddKeyAttributes, muteLanguages) {\n\n    /*\n     * Adds a `language` property to `Vue.config` and makes it reactive:\n     * Vue.config.language = 'fr_FR'\n    */\n    Object.defineProperty(Vue.config, 'language', {\n      enumerable: true,\n      configurable: true,\n      get: function () { return languageVm.current },\n      set: function (val) { languageVm.current = val; },\n    });\n\n    /*\n     * Adds a `getTextPluginSilent` property to `Vue.config`.\n     * Used to enable/disable some console warnings globally.\n    */\n    Object.defineProperty(Vue.config, 'getTextPluginSilent', {\n      enumerable: true,\n      writable: true,\n      value: getTextPluginSilent,\n    });\n\n    /*\n     * Adds an `autoAddKeyAttributes` property to `Vue.config`.\n     * Used to enable/disable the automatic addition of `key` attributes.\n    */\n    Object.defineProperty(Vue.config, 'autoAddKeyAttributes', {\n      enumerable: true,\n      writable: true,\n      value: autoAddKeyAttributes,\n    });\n\n    /*\n     * Adds a `getTextPluginMuteLanguages` property to `Vue.config`.\n     * Used to enable/disable some console warnings for a specific set of languages.\n    */\n    Object.defineProperty(Vue.config, 'getTextPluginMuteLanguages', {\n      enumerable: true,\n      writable: true,\n      value: muteLanguages,  // Stores an array of languages for which the warnings are disabled.\n    });\n\n  }\n\n  function Override (Vue, languageVm) {\n\n    // Override the main init sequence. This is called for every instance.\n    var init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      var root = options._parent || options.parent || this;\n      // Expose languageVm to every instance.\n      this.$language = root.$language || languageVm;\n      init.call(this, options);\n    };\n\n    // Override the main destroy sequence to destroy all languageVm watchers.\n    var destroy = Vue.prototype._destroy;\n    Vue.prototype._destroy = function () {\n      this.$language = null;\n      destroy.apply(this, arguments);\n    };\n\n  }\n\n  var languageVm;  // Singleton.\n\n  var GetTextPlugin = function (Vue, options) {\n    if ( options === void 0 ) options = {};\n\n\n    var defaultConfig = {\n      autoAddKeyAttributes: false,\n      availableLanguages: { en_US: 'English' },\n      defaultLanguage: 'en_US',\n      languageVmMixin: {},\n      muteLanguages: [],\n      silent: Vue.config.silent,\n      translations: null,\n    };\n\n    Object.keys(options).forEach(function (key) {\n      if (Object.keys(defaultConfig).indexOf(key) === -1) {\n        throw new Error((key + \" is an invalid option for the translate plugin.\"))\n      }\n    });\n\n    if (!options.translations) {\n      throw new Error('No translations available.')\n    }\n\n    options = Object.assign(defaultConfig, options);\n\n    languageVm = new Vue({\n      created: function () {\n        // Non-reactive data.\n        this.available = options.availableLanguages;\n      },\n      data: {\n        current: options.defaultLanguage,\n      },\n      mixins: [options.languageVmMixin],\n    });\n\n    shareVueInstance(Vue);\n\n    Override(Vue, languageVm);\n\n    Config(Vue, languageVm, options.silent, options.autoAddKeyAttributes, options.muteLanguages);\n\n    translate.initTranslations(options.translations, Vue.config);\n\n    // Makes <translate> available as a global component.\n    Vue.component('translate', Component);\n\n    // An option to support translation with HTML content: `v-translate`.\n    Vue.directive('translate', Directive);\n\n    // Exposes global properties.\n    Vue.$translations = options.translations;\n    // Exposes instance methods.\n    Vue.prototype.$gettext = translate.gettext.bind(translate);\n    Vue.prototype.$pgettext = translate.pgettext.bind(translate);\n    Vue.prototype.$ngettext = translate.ngettext.bind(translate);\n    Vue.prototype.$npgettext = translate.npgettext.bind(translate);\n    Vue.prototype.$gettextInterpolate = interpolate.bind(interpolate);\n\n  };\n\n  exports.default = GetTextPlugin;\n  exports.translate = translate;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n//# sourceURL=webpack://%5Bname%5D/./node_modules/vue-gettext/dist/vue-gettext.js?");

/***/ })

}]);